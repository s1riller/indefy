<!DOCTYPE html>
<html>
<head>
  <meta charset="windows-1251">
  <meta name="jd" content="eyJ1c2VyX2lkIjoxNDIwMzA3NjUsInRpbWVfY3VycmVudCI6MTY5MDQ0NzM0NH0">
  <title>VK</title>
  <link rel="shortcut icon" href="../../favicon.ico">
  <link rel="stylesheet" type="text/css" href="../../style.css">
</head>
<body>
  <div class="wrap">
    <div class="header">
  <div class="page_header">
    <div class="top_home_logo"></div>
  </div>
</div>
    <div class="page_content page_block">
      <h2 class="page_block_h2">
<div class="page_block_header clear_fix">
  <div class="page_block_header_extra_left _header_extra_left"></div>
  <div class="page_block_header_extra _header_extra"></div>
  <div class="page_block_header_inner _header_inner"><a class="ui_crumb" href="../../index.html">Профиль</a><div class="ui_crumb_sep"></div><a class="ui_crumb" href="../index-messages.html">Сообщения</a><div class="ui_crumb_sep"></div><div class="ui_crumb" >Анастасия Осипова</div></div>
</div>
</h2>
      <div class="wrap_page_content"><div class="item">
  <div class='item__main'><div class="message" data-id="1284949">
  <div class="message__header"><a href="https://vk.com/id324001370">Анастасия Осипова</a>, 16 июн 2022 в 18:18:08</div>
  <div>объектно-ориентированность в Lua поначалу немного пугающей.<div class="kludges"></div></div>
</div></div>
  
  
</div><div class="item">
  <div class='item__main'><div class="message" data-id="1284948">
  <div class="message__header"><a href="https://vk.com/id324001370">Анастасия Осипова</a>, 16 июн 2022 в 18:18:08</div>
  <div>unsigned int nBus; // текущее количество автобусов <br> Car C[MAX_VEHICLES]; // массив объектов класса Car <br> unsigned int nCar; // текущее количество автомобилей <br> <br>public: <br> // 1. Конструктор без параметров <br> BusStation() <br> { <br> nBus = nCar = 0; <br> } <br> <br> // 2. Методы доступа, обрабатывающие массив автобусов B[] <br> // 2.1. Получить информацию об автобусе по его номеру <br> Bus GetBus(unsigned int number) <br> { <br> // проверка, корректен ли номер <br> if (number &lt; nBus) <br> return B[number]; <br> else <br> { <br> cout « &quot;Error. Incorrect bus number.&quot; « endl; <br> return Bus(&quot;&quot;, 0); <br> } <br> } <br> <br> // 2.2. Добавить новый автобус <br> void AddBus(string model, unsigned int seats) <br> { <br> // проверка, можно ли добавлять транспортное средство <br> if ((nCar + nBus) &lt; MAX_VEHICLES) <br> { <br> nBus++; // увеличить количество автобусов на 1 <br> B[nBus - 1].Set(model, seats); // вызвать метод класса Bus <br> cout « &quot;A new bus is added&#33;&quot; « endl; <br> } <br> else <br> { <br> cout « &quot;Cannot add a new bus. Sorry&quot; « endl; <br> return; <br> } <br> } <br> <br> // 2.3. Удалить автобус из автостанции по его номеру <br> void DelBus(unsigned int number) <br> { <br> if (number &lt; nBus) <br> { <br> // цикл смещения элементов массива B <br> for (int i = number; i &lt; nBus - 1; i++) <br> B[i] = B[i + 1]; <br> nBus--; <br> } <br> } <br> <br> // 3. Методы доступа, обрабатывающие массив автомобилей C[] <br> // 3.1. Получить автомобиль по его порядковому номеру <br> Car GetCar(unsigned int number) <br> { <br> if (number &lt; nCar) <br> return C[number]; <br> else <br> { <br> cout « &quot;Error. Incorrect number of a car.&quot; « endl; <br> return Car(&quot;&quot;); <br> } <br> } <br> <br> // 3.2. Добавить новый автомобиль к автостоянке <br> void AddCar(string model) <br> { <br> // Проверка, есть ли место на автостоянке <br> if ((nCar + nBus) &lt; MAX_VEHICLES) <br> { <br> nCar++; // увеличить количество автомобилей <br> C[nCar - 1].SetModel(model); // добавить данные автомобиля <br> cout « &quot;A new car is added&#33;&quot; « endl; <br> } <br> else <br> { <br> cout « &quot;Cannot add a new car. Sorry&quot; « endl; <br> return; <br> } <br> } <br> <br> // 3.3. Удалить автомобиль из автостоянки по заданному номеру <br> void DelCar(unsigned int number) <br> { <br> if (number &lt; nCar) <br> { <br> // Цикл поэлементного сдвига с позиции number <br> for (int i = number; i &lt; nCar - 1; i++) <br> C[i] = C[i + 1]; <br> nCar--; <br> } <br> } <br> <br> // 4. Метод, выводящий информацию о размещенных <br> // в данный момент транспортных средствах на автостоянке <br> void Print() <br> { <br> cout « &quot;Info about bus station:&quot; « endl; <br> cout « &quot;nBus = &quot; « nBus « endl; <br> if (nBus &gt; 0) <br> { <br> cout « &quot;Info about buses:&quot; « endl; <br> for (int i = 0; i &lt; nBus; i++) <br> { <br> B[i].Print(); <br> } <br> } <br> cout « &quot;nCar = &quot; « nCar « endl; <br> if (nCar &gt; 0) <br> { <br> cout « &quot;Info about cars:&quot; « endl; <br> for (int i = 0; i &lt; nCar; i++) <br> { <br> C[i].Print(); <br> } <br> } <br> } <br>}; <br> <br>void main() <br>{ <br> // Демонстрация использования класса BusStation <br> // 1. Объявить экземпляр класса Автостоянка <br> BusStation bs; <br> <br> // 2. Добавить некоторые транспортные средства <br> bs.AddBus(&quot;Mersedes Sprinter&quot;, 28); <br> bs.AddBus(&quot;Renault Trafic&quot;, 29); <br> bs.AddCar(&quot;Bentley&quot;); <br> bs.AddCar(&quot;Renault Sandero&quot;); <br> <br> // 3. Вывести данные о транспорных средствах <br> bs.Print(); <br>} <br>Результат работы программы: <br> <br>Примеры композиции для типа отношения has-a <br>В примере продемонстрирована композиция для классов Vehicle, Wheel, Car. В автомобиль (Car) входят двигатель (класс Vehicle) и колесо (Wheel), которые являются его составной частью – это есть композиция (объединение). <br>// Класс Двигатель <br>class Vehicle <br>{ <br> // Поля и методы класса <br> // ... <br>}; <br> <br>// Класс Колесо <br>class Wheel <br>{ <br> // Поля и методы класса <br> // ... <br>}; <br> <br>// Класс Автомобиль - содержит обязательные элементы, <br>// которые есть составляющими Автомобиля <br>class Car <br>{ <br> // Экземпляры обязательных классов, <br> // которые есть частью данного класса - это композиция <br>private: <br> Vehicle veh; // автомобиль содержит двигатель (обязательно) <br> Wheel whl[4]; // колеса - 4 штуки (обязательно) <br> <br> // Поля и методы класса <br> // ... <br>}; <br>По умолчанию Lua не имеет системы классов, но его мощные средства метапрограммирования упрощают определение классических объектов. На самом деле, есть несколько способов сделать это; вместе с незнакомой нотацией это делает<div class="kludges"></div></div>
</div></div>
  
  
</div><div class="item">
  <div class='item__main'><div class="message" data-id="1284947">
  <div class="message__header"><a href="https://vk.com/id324001370">Анастасия Осипова</a>, 16 июн 2022 в 18:18:07</div>
  <div>// 2. Добавить некоторые транспортные средства <br> bs.AddBus(&quot;Mersedes Sprinter&quot;, 28); <br> bs.AddBus(&quot;Renault Trafic&quot;, 29); <br> bs.AddCar(&quot;Bentley&quot;); <br> bs.AddCar(&quot;Renault Sandero&quot;); <br> <br> // 3. Вывести данные о транспорных средствах <br> bs.Print(); <br>} <br>Результат выполнения программы: <br> <br> Примеры отношения между классами типа has-a <br>При отношении has-a класс содержит один или несколько объектов (экземпляров) другого класса. Существуют два вида отношения has-a: <br>агрегация. Это случай, когда один или несколько вложенных объектов не являются частью класса. Класс может содержать любое количество таких объектов (даже 0). Для лучшего изучения агрегации смотрите приведенные ниже примеры; <br>композиция. В этом случае один или несколько вложенных объектов есть частью класса, то есть без этих объектов невозможно логическое существование самого класса. <br>Примеры агрегации для типа отношения has-a <br>В случае агрегации класс содержит множество (один или несколько) объектов других классов, которые не являются составной частью этого класса (не содержат код, который дополняет работу самого класса). <br>В данном сокращенном коде демонстрируется агрегация на примере классов Triangle, Circle, Figures. Класс Figures может содержать разное количество разных фигур (даже 0). По возможности к классу Figures могут быть добавлены массивы других фигур, например, Rectangle (прямоугольник). В любом случае, класс Figures будет полноценным функционально, значит, это есть агрегация. <br>// Класс треугольник <br>class Triangle <br>{ <br> // Методы и поля класса Triangle <br> // ... <br>}; <br> <br>// Класс, реализующий окружность <br>class Circle <br>{ <br> // Методы и поля класса Circle <br> // ... <br>}; <br> <br>// Класс, реализующий различные геометрические фигуры. <br>// Используется тип отношения - агрегация. <br>class Figures <br>{ <br> Triangle tr[10]; // массив треугольников <br> unsigned int n_tr; // количество треугольников в массиве tr <br> Circle cr[10]; // массив окружностей <br> unsigned int n_cr; // количество окружностей в массиве cr <br> <br> // Другие поля и методы класса <br> // ... <br>}; <br>В примере класс BusStation (Автостанция) содержит массивы экземпляров классов Bus (Автобус), Car (Автомобиль). Количество элементов в массивах классов Bus и Car может изменяться. Даже, если на автостанции в данный момент времени не будет ни одного автобуса или автомобиля, автостанция будет функционировать. Это есть агрегация. <br>#include &lt;iostream&gt; <br>using namespace std; <br> <br>// C++. Демонстрация отношения has-a <br>// Максимально-возможное количество транспортных средств на автостанции <br>const int MAX_VEHICLES = 10; <br> <br>// Класс Автомобиль <br>class Car <br>{ <br> // 1. Скрытые внутренние поля класса <br>private: <br> string model; // марка автомобиля <br> <br>public: <br> // 2. Конструкторы класса <br> // 2.1. Главный конструктор класса с 1 параметром <br> Car(string _model) :model(_model) <br> { <br> } <br> <br> // 2.2. Конструктор без параметров, <br> // осуществляет вызов главного конструктора <br> Car() : Car(&quot;&quot;) <br> { <br> } <br> <br> // 3. Методы доступа к полям класса <br> string GetModel() { return model; } <br> void SetModel(string _model) <br> { <br> model = _model; <br> } <br> <br> // 4. Метод, отображающий информацию об автомобиле <br> void Print() <br> { <br> cout « &quot;model = &quot; « model « endl; <br> } <br>}; <br> <br>// Класс Автобус <br>class Bus <br>{ <br> // 1. Скрытые внутренние поля <br>private: <br> string model; // Марка автобуса <br> unsigned int seats; // количество посадочных мест <br> <br>public: <br> // 2. Конструкторы <br> // 2.1. Конструктор с 2 параметрами - главный конструктор <br> Bus(string _model, int _seats) : model(model), seats(_seats) <br> { <br> } <br> <br> // 2.2. Конструктор без параметров, <br> // осуществляет вызов клавного конструктора <br> Bus() : Bus(&quot;&quot;, 0) {} <br> <br> // 3. Методы доступа <br> void Get(string&amp; _model, int&amp; _seats) <br> { <br> _model = model; <br> _seats = seats; <br> } <br> <br> void Set(string _model, int _seats) <br> { <br> model = _model; <br> seats = _seats; <br> } <br> <br> // 4. Метод, отображающий информацию об автобусе <br> void Print() <br> { <br> cout « &quot;model = &quot; « model « &quot;, seats = &quot; « seats « endl; <br> } <br>}; <br> <br>// Класс Автостанция - содержит массивы классов Bus, Car <br>class BusStation <br>{ <br>private: <br> Bus B[MAX_VEHICLES]; // массив объектов класса Bus - отношение has-a<div class="kludges"></div></div>
</div></div>
  
  
</div><div class="item">
  <div class='item__main'><div class="message" data-id="1284946">
  <div class="message__header"><a href="https://vk.com/id324001370">Анастасия Осипова</a>, 16 июн 2022 в 18:18:06</div>
  <div>2.2. Конструктор без параметров, <br> // осуществляет вызов главного конструктора <br> Car() : Car(&quot;&quot;) <br> { <br> } <br> <br> // 3. Методы доступа к полям класса <br> string GetModel() { return model; } <br> void SetModel(string _model) <br> { <br> model = _model; <br> } <br> <br> // 4. Метод, отображающий информацию об автомобиле <br> void Print() <br> { <br> cout « &quot;model = &quot; « model « endl; <br> } <br>}; <br> <br>// Класс Автобус <br>class Bus <br>{ <br> // 1. Скрытые внутренние поля <br>private: <br> string model; // Марка автобуса <br> unsigned int seats; // количество посадочных мест <br> <br>public: <br> // 2. Конструкторы <br> // 2.1. Конструктор с 2 параметрами - главный конструктор <br> Bus(string _model, int _seats) : model(model), seats(_seats) <br> { <br> } <br> <br> // 2.2. Конструктор без параметров, <br> // осуществляет вызов клавного конструктора <br> Bus() : Bus(&quot;&quot;, 0) {} <br> <br> // 3. Методы доступа <br> void Get(string&amp; _model, int&amp; _seats) <br> { <br> _model = model; <br> _seats = seats; <br> } <br> <br> void Set(string _model, int _seats) <br> { <br> model = _model; <br> seats = _seats; <br> } <br> <br> // 4. Метод, отображающий информацию об автобусе <br> void Print() <br> { <br> cout « &quot;model = &quot; « model « &quot;, seats = &quot; « seats « endl; <br> } <br>}; <br> <br>// Класс Автостанция - содержит массивы классов Bus, Car <br>class BusStation <br>{ <br>private: <br> Bus B[MAX_VEHICLES]; // массив объектов класса Bus - отношение has-a <br> unsigned int nBus; // текущее количество автобусов <br> Car C[MAX_VEHICLES]; // массив объектов класса Car <br> unsigned int nCar; // текущее количество автомобилей <br> <br>public: <br> // 1. Конструктор без параметров <br> BusStation() <br> { <br> nBus = nCar = 0; <br> } <br> <br> // 2. Методы доступа, обрабатывающие массив автобусов B[] <br> // 2.1. Получить информацию об автобусе по его номеру <br> Bus GetBus(unsigned int number) <br> { <br> // проверка, корректен ли номер <br> if (number &lt; nBus) <br> return B[number]; <br> else <br> { <br> cout « &quot;Error. Incorrect bus number.&quot; « endl; <br> return Bus(&quot;&quot;, 0); <br> } <br> } <br> <br> // 2.2. Добавить новый автобус <br> void AddBus(string model, unsigned int seats) <br> { <br> // проверка, можно ли добавлять транспортное средство <br> if ((nCar + nBus) &lt; MAX_VEHICLES) <br> { <br> nBus++; // увеличить количество автобусов на 1 <br> B[nBus - 1].Set(model, seats); // вызвать метод класса Bus <br> cout « &quot;A new bus is added&#33;&quot; « endl; <br> } <br> else <br> { <br> cout « &quot;Cannot add a new bus. Sorry&quot; « endl; <br> return; <br> } <br> } <br> <br> // 2.3. Удалить автобус из автостанции по его номеру <br> void DelBus(unsigned int number) <br> { <br> if (number &lt; nBus) <br> { <br> // цикл смещения элементов массива B <br> for (int i = number; i &lt; nBus - 1; i++) <br> B[i] = B[i + 1]; <br> nBus--; <br> } <br> } <br> <br> // 3. Методы доступа, обрабатывающие массив автомобилей C[] <br> // 3.1. Получить автомобиль по его порядковому номеру <br> Car GetCar(unsigned int number) <br> { <br> if (number &lt; nCar) <br> return C[number]; <br> else <br> { <br> cout « &quot;Error. Incorrect number of a car.&quot; « endl; <br> return Car(&quot;&quot;); <br> } <br> } <br> <br> // 3.2. Добавить новый автомобиль к автостоянке <br> void AddCar(string model) <br> { <br> // Проверка, есть ли место на автостоянке <br> if ((nCar + nBus) &lt; MAX_VEHICLES) <br> { <br> nCar++; // увеличить количество автомобилей <br> C[nCar - 1].SetModel(model); // добавить данные автомобиля <br> cout « &quot;A new car is added&#33;&quot; « endl; <br> } <br> else <br> { <br> cout « &quot;Cannot add a new car. Sorry&quot; « endl; <br> return; <br> } <br> } <br> <br> // 3.3. Удалить автомобиль из автостоянки по заданному номеру <br> void DelCar(unsigned int number) <br> { <br> if (number &lt; nCar) <br> { <br> // Цикл поэлементного сдвига с позиции number <br> for (int i = number; i &lt; nCar - 1; i++) <br> C[i] = C[i + 1]; <br> nCar--; <br> } <br> } <br> <br> // 4. Метод, выводящий информацию о размещенных <br> // в данный момент транспортных средствах на автостоянке <br> void Print() <br> { <br> cout « &quot;Info about bus station:&quot; « endl; <br> cout « &quot;nBus = &quot; « nBus « endl; <br> if (nBus &gt; 0) <br> { <br> cout « &quot;Info about buses:&quot; « endl; <br> for (int i = 0; i &lt; nBus; i++) <br> { <br> B[i].Print(); <br> } <br> } <br> cout « &quot;nCar = &quot; « nCar « endl; <br> if (nCar &gt; 0) <br> { <br> cout « &quot;Info about cars:&quot; « endl; <br> for (int i = 0; i &lt; nCar; i++) <br> { <br> C[i].Print(); <br> } <br> } <br> } <br>}; <br> <br>void main() <br>{ <br> // Демонстрация использования класса BusStation <br> // 1. Объявить экземпляр класса Автостоянка <br> BusStation bs;<div class="kludges"></div></div>
</div></div>
  
  
</div><div class="item">
  <div class='item__main'><div class="message" data-id="1284945">
  <div class="message__header"><a href="https://vk.com/id324001370">Анастасия Осипова</a>, 16 июн 2022 в 18:18:05</div>
  <div>один раз непосредственно при их объявлении и впоследствии не может быть изменено. Кроме того, константы хранят некоторые данные, которые относятся не к одному объекту, а ко всему классу в целом. И для обращения к константам применяется не имя объекта, а имя класса: <br>Person tom = new Person(); <br>tom.name = &quot;Tom&quot;; <br>tom.age = 37; <br>tom.Print(); // Person: Tom - 37 <br> <br>Console.WriteLine(Person.type); // Person <br>// Person.type = &quot;User&quot;; // &#33;Ошибка: изменить константу нельзя <br> <br>class Person <br>{ <br> public const string type = &quot;Person&quot;; <br> public string name = &quot;Undefined&quot;; <br> public int age; <br> public void Print() =&gt; Console.WriteLine(&#036;&quot;{type}: {name} - {age}&quot;); <br>} <br>Здесь в классе Person определена константа type, которая хранит название класса: <br>public const string type = &quot;Person&quot;; <br>Название класса не зависит от объекта. Мы можем создать много объектов Person, но название класса от этого не должно измениться - оно относится ко всем объектам Person и не должно меняться. Поэтому название типа можно сохранить в виде константы. <br> <br>Стоит отметить, что константе сразу при ее определении необходимо присвоить значение. <br> <br>Подобно обычным полям мы можем обращаться к константам класса внутри этого класса. Например, в методе Print значение константы выводится на консоль. <br> <br>Однако если мы хотим обратиться к константе вне ее класса, то для обращения необходимо использовались имя класса: <br>Console.WriteLine(Person.type); // Person <br>Таким образом, если необходимо хранить данные, которые относятся ко всему классу в целом, то можно использовать константы. <br>Дальше про взаимодействие между классами. <br>Между классами возможны два типа отношений: <br>Отношение типа is-a (есть, является), при котором один класс есть подвидом другого класса. При таком отношении один класс расширяет (детализирует) возможности другого класса. Расширение возможностей класса осуществляется благодаря использованию наследования. <br>Отношение, при котором существует взаимосвязь между двумя классами. Здесь выделяют два подвида взаимосвязи между классами: <br>Отношение типа has-a (класс содержит другой класс). В этом случае в классе объявляется одних или несколько экземпляров другого класса. При данном отношении возможны два случая взаимодействия. Первый случай, это когда объект (экземпляр), который объявлен в классе, не является составной частью класса (агрегация) и его использование не влияет на функциональную работу класса. Второй случай, когда объект, который объявлен в классе, есть составной частью этого класса (композиция). <br>Отношение типа uses (класс «использует другой класс). В этом случае класс содержит программный код другого вложенного класса, к которому он имеет доступ. Более подробно об особенностях использования отношения типа uses описывается здесь. <br> Пример простейшего типа отношения is-a (наследование) <br>Суть отношения типа is-a состоит в том, что класс есть подвидом другого класса. В данном примере базовый класс Circle расширяется классом CircleColor. Класс CircleColor есть подвидом класса Circle и добавляет к нему поле цвета. <br>В классе Circle реализованы следующие элементы: <br>внутренние скрытые (private) поля x, y, r; <br>конструктор Circle() с 3 параметрами, которые заполняют значения внутренних полей; <br>методы доступа GetXYR(), SetXYR() к полям класса; <br>функция Area() вычисления площади круга. <br>В производном классе CircleColor реализованы поля и методы, которые дополняют класс Color: <br>внутреннее скрытое поле класса color; <br>конструктор CircleColor() с 4 параметрами, который обращается к конструктору класса Color; <br>методы GetColor(), SetColor() для доступа к скрытой переменной color. <br>Демонстрационный текст программы на C++ следующий: <br> <br>#include &lt;iostream&gt; <br>using namespace std; <br> <br>// C++. Демонстрация отношения has-a <br>// Максимально-возможное количество транспортных средств на автостанции <br>const int MAX_VEHICLES = 10; <br> <br>// Класс Автомобиль <br>class Car <br>{ <br> // 1. Скрытые внутренние поля класса <br>private: <br> string model; // марка автомобиля <br> <br>public: <br> // 2. Конструкторы класса <br> // 2.1. Главный конструктор класса с 1 параметром <br> Car(string _model) :model(_model) <br> { <br> } <br> <br> //<div class="kludges"></div></div>
</div></div>
  
  
</div><div class="item">
  <div class='item__main'><div class="message" data-id="1284944">
  <div class="message__header"><a href="https://vk.com/id324001370">Анастасия Осипова</a>, 16 июн 2022 в 18:18:04</div>
  <div>Описанием объекта является класс, а объект представляет экземпляр этого класса. Можно еще провести следующую аналогию. <br>По сути класс представляет новый тип, который определяется пользователем. Класс определяется с помощью ключевого слова сlass (c++): <br>class название_класса <br>{ <br> // содержимое класса <br>} <br>Класс может хранить некоторые данные. Для хранения данных в классе применяются поля. По сути поля класса - это переменные, определенные на уровне класса. <br> <br>Кроме того, класс может определять некоторое поведение или выполняемые действия. Для определения поведения в классе применяются методы. <br>Итак, добавим в класс Person поля и методы: <br>class Person <br>{ <br> public string name = &quot;Undefined&quot;; // имя <br> public int age;  // возраст <br> <br> public void Print() <br> { <br> Console.WriteLine(&#036;&quot;Имя: {name} Возраст: {age}&quot;); <br> } <br>} <br>В данном случае в классе Person определено поле name, которое хранит имя, и поле age, которое хранит возраст человека. В отличие от переменных, определенных в методах, поля класса могут иметь модификаторы, которые указываются перед полем. Так, в данном случае, чтобы все поля были доступны вне класса Person поля определены с модификатором public. <br>При определении полей мы можем присвоить им некоторые значения, как в примере выше в случае переменной name. Если поля класса не инициализированы, то они получают значения по умолчанию. Для переменных числовых типов это число 0. <br>Также в классе Person определен метод Print(). Методы класса имеют доступ к его поля, и в данном случае обращаемся к полям класса name и age для вывода их значения на консоль. И чтобы этот метод был виден вне класса, он также определен с модификатором public. <br>Создание объекта класса <br>После определения класса мы можем создавать его объекты. Для создания объекта применяются конструкторы. По сути конструкторы представляют специальные методы, которые называются так же как и класс, и которые вызываются при создании нового объекта класса и выполняют инициализацию объекта. Общий синтаксис вызова конструктора: <br>new конструктор_класса(параметры_конструктора); <br>Сначала идет оператор new, который выделяет память для объекта, а после него идет вызов конструктора. <br>Конструктор по умолчанию <br>Если в классе не определено ни одного конструктора (как в случае с нашим классом Person), то для этого класса автоматически создается пустой конструктор по умолчанию, который не принимает никаких параметров. <br>Теперь создадим объект класса Person: <br>Person tom = new Person(); // создание объекта класса Person <br> <br>// определение класса Person <br>class Person <br>{ <br> public string name = &quot;Undefined&quot;; <br> public int age; <br> <br> public void Print() <br> { <br> Console.WriteLine(&#036;&quot;Имя: {name} Возраст: {age}&quot;); <br> } <br>} <br>Для создания объекта Person используется выражение new Person(). В итоге после выполнения данного выражения в памяти будет выделен участок, где будут храниться все данные объекта Person. А переменная tom получит ссылку на созданный объект, и через эту переменную мы можем использовать данный объект и обращаться к его функциональности. <br>Обращение к функциональности класса <br>Для обращения к функциональности класса - полям, методам (а также другим элементам класса) применяется точечная нотация точки - после объекта класса ставится точка, а затем элемент класса: <br>объект.поле_класса <br>объект.метод_класса(параметры_метода) <br>Например, обратимся к полям и методам объекта Person: <br>Person tom = new Person(); // создание объекта класса Person <br> <br>// Получаем значение полей в переменные <br>string personName = tom.name; <br>int personAge = tom.age; <br>Console.WriteLine(&#036;&quot;Имя: {personName} Возраст {personAge}&quot;); // Имя: Undefined Возраст: 0 <br> <br>// устанавливаем новые значения полей <br>tom.name = &quot;Tom&quot;; <br>tom.age = 37; <br> <br>// обращаемся к методу Print <br>tom.Print(); // Имя: Tom Возраст: 37 <br> <br>class Person <br>{ <br> public string name = &quot;Undefined&quot;; <br> public int age; <br> <br> public void Print() <br> { <br> Console.WriteLine(&#036;&quot;Имя: {name} Возраст: {age}&quot;); <br> } <br>} <br>Консольный вывод данной программы: <br> <br>Константы классы <br>Кроме полей класс может определять для хранения данных константы. В отличие от полей из значение устанавливается<div class="kludges"></div></div>
</div></div>
  
  
</div>      </div>
    </div>
  </div>
</body>
</html>